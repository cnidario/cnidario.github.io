<!doctype html><html lang=en><meta charset=utf-8><title>highly experimental lemonade - Conway’s Game of Life in Rust
with macroquad</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/dist/css/water.css><link rel=stylesheet href=/dist/css/style.css><link rel=stylesheet href=/dist/css/highlight.css><header><h1>highlyexperimentallemonade</h1><nav><ul><li><a href=/dist/home.html>home</a><li><a href=/dist/posts.html>posts</a><li><a href=/dist/about.html>about</a></ul></nav></header><h1 class=title>Conway’s Game of Life in Rust with macroquad</h1><p class=date>2022-09-28<main><p><a href=https://macroquad.rs>Macroquad</a> is a small Rust library
to make graphical apps with little code. Think it as a <a href=https://love2d.org>LÖVE</a> or a <a href=https://processing.org>Processing</a> but for Rust. I wanted to
test it by making an implementation of <a href=https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life>Conway’s
game of life</a>.<h1 id=result>Result</h1><figure><img src=../img/conway-rust.png alt=Screenshot><figcaption aria-hidden=true>Screenshot</figcaption></figure><h1 id=data-structure>Data structure</h1><p>Very simple. Justa a matrix of boolean values indicating if the cell
is alive or not.<pre><code class=rust><div class=highlight><pre><span></span><span class=cp>#[derive(Clone)]</span><span class=w></span>
<span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>World</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>step</span>: <span class=kt>u32</span><span class=p>,</span><span class=w></span>
<span class=w>    </span><span class=n>width</span>: <span class=kt>usize</span><span class=p>,</span><span class=w></span>
<span class=w>    </span><span class=n>height</span>: <span class=kt>usize</span><span class=p>,</span><span class=w></span>
<span class=w>    </span><span class=n>cells</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</pre></div></code></pre><h1 id=functions>Functions</h1><pre><code class=rust><div class=highlight><pre><span></span><span class=c1>// Compute the next step of the world</span>
<span class=k>fn</span> <span class=nf>update_world</span><span class=p>(</span><span class=n>world_now</span>: <span class=kp>&amp;</span><span class=nc>World</span><span class=p>,</span><span class=w> </span><span class=n>world_next</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>World</span><span class=p>)</span><span class=w></span>
<span class=c1>// Compute the number of alive neighbours of a cell at i row, and j column</span>
<span class=k>fn</span> <span class=nf>alive_neighbours</span><span class=p>(</span><span class=n>w</span>: <span class=kp>&amp;</span><span class=nc>World</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>j</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span>
<span class=c1>// Selects the neighbours of a cell at i row and j column</span>
<span class=k>fn</span> <span class=nf>neighbours</span><span class=p>(</span><span class=n>world</span>: <span class=kp>&amp;</span><span class=nc>World</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>j</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span><span class=w></span>
</pre></div></code></pre><h1 id=tests>Tests</h1><p>The most important tests check the count of alive neighbours with
special attention to wrapping (when you overflow or underflow the index
of the world and it gets wrapped like a ‘round’ globe world). And the
basic rules:<pre><code class=console><div class=highlight><pre><span></span><span class=gp>cni@mil:(master)$~/D/P/P/r/m/conway(148)$ </span>cargo t
<span class=go>   Compiling conway v0.1.0 (/home/cnidario/Documents/Personal/Proyectos/rust/macroquad/conway)</span>
<span class=go>    Finished test [unoptimized + debuginfo] target(s) in 1.58s</span>
<span class=go>     Running unittests src/main.rs (target/debug/deps/conway-aeaeacb751c479dd)</span>

<span class=go>running 4 tests</span>
<span class=go>test tests::test_neighbour_count ... ok</span>
<span class=go>test tests::test_superpopulation_and_reproduce ... ok</span>
<span class=go>test tests::test_underpopulation ... ok</span>
<span class=go>test tests::test_blinker ... ok</span>

<span class=go>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span>
</pre></div></code></pre><ol type=1><li>Neighbour count</ol><pre><code class=rust><div class=highlight><pre><span></span><span class=w>    </span><span class=cp>#[test]</span><span class=w></span>
<span class=w>    </span><span class=k>fn</span> <span class=nf>test_neighbour_count</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=o>&amp;</span><span class=fm>vec!</span><span class=p>[</span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>],</span><span class=w> </span><span class=mi>3</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>),</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>),</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=mi>4</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>alive_neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world0</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>
</pre></div></code></pre><ol start=2 type=1><li>Underpopulation</ol><pre><code class=rust><div class=highlight><pre><span></span><span class=w>    </span><span class=cp>#[test]</span><span class=w></span>
<span class=w>    </span><span class=k>fn</span> <span class=nf>test_underpopulation</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=o>&amp;</span><span class=fm>vec!</span><span class=p>[</span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>],</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=o>&amp;</span><span class=fm>vec!</span><span class=p>[</span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>],</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world_before</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=n>update_world</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world_before</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>world_next</span><span class=p>.</span><span class=n>cells</span><span class=p>,</span><span class=w> </span><span class=n>world1</span><span class=p>.</span><span class=n>cells</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world_before</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_next</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=n>update_world</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world_before</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>world_next</span><span class=p>.</span><span class=n>cells</span><span class=p>,</span><span class=w> </span><span class=n>world1</span><span class=p>.</span><span class=n>cells</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>
</pre></div></code></pre><ol start=3 type=1><li>Superpopulation & reproduce</ol><pre><code class=rust><div class=highlight><pre><span></span><span class=w>    </span><span class=cp>#[test]</span><span class=w></span>
<span class=w>    </span><span class=k>fn</span> <span class=nf>test_superpopulation_and_reproduce</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=w></span>
<span class=w>            </span><span class=o>&amp;</span><span class=fm>vec!</span><span class=p>[</span><span class=w></span>
<span class=w>                </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w></span>
<span class=w>            </span><span class=p>],</span><span class=w></span>
<span class=w>            </span><span class=mi>5</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=w></span>
<span class=w>            </span><span class=o>&amp;</span><span class=fm>vec!</span><span class=p>[</span><span class=w></span>
<span class=w>                </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=p>,</span><span class=w></span>
<span class=w>            </span><span class=p>],</span><span class=w></span>
<span class=w>            </span><span class=mi>5</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world_before</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=n>update_world</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world_before</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>world_next</span><span class=p>.</span><span class=n>cells</span><span class=p>,</span><span class=w> </span><span class=n>world1</span><span class=p>.</span><span class=n>cells</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>
</pre></div></code></pre><ol start=4 type=1><li>Blinker. A blinker is an special pattern of Conway’s game of life,
the simplest oscillator.</ol><pre><code class=rust><div class=highlight><pre><span></span><span class=w>    </span><span class=cp>#[test]</span><span class=w></span>
<span class=w>    </span><span class=k>fn</span> <span class=nf>test_blinker</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=o>&amp;</span><span class=n>BLINKER0</span><span class=p>.</span><span class=n>to_vec</span><span class=p>(),</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_from_map</span><span class=p>(</span><span class=o>&amp;</span><span class=n>BLINKER1</span><span class=p>.</span><span class=n>to_vec</span><span class=p>(),</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world_before</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=n>update_world</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world_before</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>world_next</span><span class=p>.</span><span class=n>cells</span><span class=p>,</span><span class=w> </span><span class=n>world1</span><span class=p>.</span><span class=n>cells</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=c1>//</span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world_before</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_next</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=n>update_world</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world_before</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>world_next</span><span class=p>.</span><span class=n>cells</span><span class=p>,</span><span class=w> </span><span class=n>world0</span><span class=p>.</span><span class=n>cells</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=c1>//</span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>world_before</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>world_next</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w></span>
<span class=w>        </span><span class=n>update_world</span><span class=p>(</span><span class=o>&amp;</span><span class=n>world_before</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>world_next</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>world_next</span><span class=p>.</span><span class=n>cells</span><span class=p>,</span><span class=w> </span><span class=n>world1</span><span class=p>.</span><span class=n>cells</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>
</pre></div></code></pre><h1 id=comments>Comments</h1><ul><li>Macroquad is an easy library, and Conway’s game of life is an easy
exercise to implement, while learning Rust.<li>Maybe my solution is not very efficient, because it relies in
copying the world state every step. It also steps over each array
location. Though not copying the state would complicate the logic (or
the data structure). I think also that my solution trashes an entire
world of cells matrix every step causing maybe lots of memory
allocations and deallocations, I could use in-place editing instead of
this and rotate the 2 matrix each step. Anyway I should measure before
making assumptions.<li>I regret the chosen data structure, it would be easier to implement
with a flat vector, anyways the cell information is stored raw and does
not use any kind of compression scheme (like in sparse structures).<li>Also <code>Vec&lt;bool></code> is not space-optimal. Would be
interesting research into <code>bit-vec</code> or <code>bitvec</code>
crates. Or maybe experimenting with <code>u8/u16/...</code> and use bit
arithmetic.<li>An small efficiency improvement would be to calculate directly
<code>alive_neighbours</code> without computing a vector of them.<li>I underestimated the ‘simple’ neighbours function at first (I didn’t
even plan at the beginning to make a test for this, but after some
problems with a bad wrap arithmetic it helped me to solve it.<li>Rust type system is strong, and mostly helpful, sometimes tricky. I
can write a lot with some kind of functional style, but not all I’ll do
with other functional language like Haskell.<li>Rust aritmetic comes also with strong guarantees, though you can
really break your code (it’s not bullet proof like its memory
model).</ul><p>Here is an example of an arithmetic unsafe program in Rust (it panics
without noticing the programmer). You can test it online in <a href=https://play.rust-lang.org>Rust Playground</a><pre><code class=rust><div class=highlight><pre><span></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>u</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>u</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&quot;{u}&quot;</span><span class=p>);</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</pre></div></code></pre><p>Output<pre><code class=console><div class=highlight><pre><span></span><span class=go> Compiling playground v0.0.1 (/playground)</span>
<span class=go>    Finished dev [unoptimized + debuginfo] target(s) in 2.42s</span>
<span class=go>     Running `target/debug/playground`</span>
<span class=go>thread &#39;main&#39; panicked at &#39;attempt to subtract with overflow&#39;, src/main.rs:5:5</span>
<span class=go>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span>
</pre></div></code></pre></main><footer>made by me</footer>